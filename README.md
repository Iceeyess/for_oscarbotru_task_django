Тестовое задание для Django

Необходимо на Django создать сервис рассылки.

Данный сервис будет являться частью микро-сервисной архитектуры, которая обеспечивает работу большого проекта в части
уведомлений пользователей на email или в telegram.

Спецификация:
Сервис должен иметь одну точку входа: /api/notify/
Тело запроса должно обязательно включать следующие параметры:

{
"message": string(1024),
"recepient": string(150) | list[string(150)],
"delay": int
}
Параметр message содержит обычный текст, который будет отправлен в сообщении

Параметр "recepient" может содержать одного получателя или список получателей.
При этом необходимо определять для каждого получателя, предоставлен адрес для отправки на почту или в telegram.
В получателе telegram всегда только числа, почта оформлена по общей маске почтового адреса.

Параметр delay отвечает за задержку отправки, где:

- 0 - отправлять без задержки, при получении запроса
- 1 - отправить с задержкой в 1 час
- 2 - отправить с задержкой в 1 день

Дополнительно:
При получении сообщение должно складываться в отдельную таблицу, а при рассылке необходимо записывать лог о попытке
отправки в БД. Сама отправка должна осуществляться с помощью очереди через celery.
Все доступы для отправки указываются внутри микросервиса.

Оформление:
Проект должен быть оформлен согласно PEP8 и также проходить проверку типизации.

Результат работы необходимо сдать ссылкой на github репозиторий

------------------------------------------------------------------------------------------------------------------------

Реализация задания и мои комментарии (Крашенинникова Дмитрия):
При отправки JSON файла на вход параметр "recepient" идет проверка на структуру типизации:

- Если приходит список, то идет циклический процесс создания объектов модели Notifications по каждому из получателю
  сообщения, при этом параллельно проходит валидация данных на структуру данных (должны допускаться только цифры в
  объекте
  или структура email),
  в противном случае вернется ошибка с пояснением ошибки. При этом возврат ответа идет по той же структуре данных:
  Список,
  а в списке словарь из созданных объектов.
- Если приходит один объект с типом строка, то идет так же проверка на структуру данных(email, только цифры - tg
  chat_id).
  По всем объекта идет проверка с двух сторон, на стороне модели, а так же на стороне сериализатора на кол-во символов
  в 150.
  Понятно, что вторая проверка лишняя, но решил оставить для порядка.
  Реализация задержки в формате даты и время прошла в методе create в serializers.py, ровно так же прошла проверка и
  установка типа сообщения/программа мессенджера, в соответствии от того, что пришло на вход в параметре recipient. 
- так же присутствует валидация на входящий параметр "delay", чтобы был диапазон целых чисел 0 - 2.  
По параметру "recipient". Если в списке будут структурированные данные в формате email или tg chat_id , то объекты Notification будут 
создаваться только на те данные, по которые формат корректен, а если в списке будет так же кривой формат, например, 
"asd234@@", "" и т.п., то объект Notification программа создавать не будет, однако вернет сообщение об ошибке, но остальные данные создаст. 
Например, если мы имеем данные:

{
"message": "Hello, world!",
"recipient": ["5762934754", "ice_eyes@mail.ru", "test@test.ru", "фыв234@@", ""],
"delay":0
}

, то в БД на следующие объекты создаться сообщение: ["5762934754", "ice_eyes@mail.ru", "test@test.ru", но программа вернет:

{
    "recipient": [
        "Получатель должен быть валидным адресом электронной почты или номером Телеграм состоящий только из цифр."
]
}

Изначально я предположил, что программа должна выдавать такой ответ:

[

{объект№ 1 был создан с такими-то параметрами}, 

{объект№ 2 был создан с такими-то параметрами}, 

{объект№ 3 был создан с такими-то параметрами}, 

{ошибка в валидации},

{ошибка в валидации}

].

Скажу честно, мне не удалось получить такой формат, но я долго времени не уделял такому кейсы , если критично,
скажите, буду думать, переделаю.

Итого реализовал 2 модели:
- Notification: id, message, recipient, delay, next_send, type, creation_datetime, update_datetime, log.
- LogInfo: status, code, creation_datetime, update_datetime.

Тесты делать не стал, не было в задании, хотя проверить APIView можно было, но протестировал очень много кейсов, и смысла 
не увидел.
